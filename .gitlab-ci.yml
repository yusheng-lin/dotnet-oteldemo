stages:
  - build
  - deploy

variables:
  # Use Minikube's Docker daemon
  DOCKER_HOST: ""
  # Kubernetes namespace
  K8S_NAMESPACE: otel-demo
  # Image registry (using Minikube's local registry)
  REGISTRY: localhost:5000

# Build stage - builds Docker images for all services
build-images:
  stage: build
  tags:
    - minikube  # Use a runner with minikube access
  before_script:
    # Point to Minikube's Docker daemon
    - eval $(minikube docker-env)
  script:
    - echo "Building Docker images..."
    # Build gateway service
    - docker build -t ${REGISTRY}/gateway:${CI_COMMIT_SHORT_SHA} -t ${REGISTRY}/gateway:latest ./gateway
    # Build order service
    - docker build -t ${REGISTRY}/orderservice:${CI_COMMIT_SHORT_SHA} -t ${REGISTRY}/orderservice:latest ./orderservice
    # Build payment service
    - docker build -t ${REGISTRY}/paymentservice:${CI_COMMIT_SHORT_SHA} -t ${REGISTRY}/paymentservice:latest ./paymentservice
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "master"
    - when: manual

# Deploy infrastructure components
deploy-infra:
  stage: deploy
  tags:
    - minikube
  before_script:
    - kubectl config use-context minikube
  script:
    - echo "Deploying infrastructure to Minikube..."
    # Create namespace
    - kubectl apply -f k8s/00-namespace.yaml
    # Deploy MySQL
    - kubectl apply -f k8s/01-mysql.yaml
    # Wait for MySQL to be ready
    - kubectl wait --for=condition=ready pod -l app=mysql -n ${K8S_NAMESPACE} --timeout=120s || true
    # Deploy Jaeger
    - kubectl apply -f k8s/02-jaeger.yaml
    # Deploy OpenTelemetry Collector
    - kubectl apply -f k8s/02-1-otel-collector.yaml
    # Deploy Elasticsearch
    - kubectl apply -f k8s/03-elasticsearch.yaml
    # Deploy Kibana
    - kubectl apply -f k8s/04-kibana.yaml
    # Deploy Kafka
    - kubectl apply -f k8s/05-kafka.yaml
    # Deploy Logstash
    - kubectl apply -f k8s/06-logstash.yaml
    # Deploy Kong
    - kubectl apply -f k8s/07-kong.yaml
    # Deploy Keycloak
    - kubectl apply -f k8s/08-keycloak.yaml
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "master"
    - when: manual

# Deploy application components
deploy-apps:
  stage: deploy
  tags:
    - minikube
  needs:
    - deploy-infra
    - build-images
  before_script:
    - kubectl config use-context minikube
  script:
    - echo "Deploying applications to Minikube..."
    # Deploy ConfigMaps
    - kubectl apply -f k8s/09-config.yaml
    # Deploy application services
    - kubectl apply -f k8s/10-apps.yaml
    # Deploy gateway
    - kubectl apply -f k8s/11-gateway.yaml
    # Configure Kong routes
    - kubectl apply -f k8s/12-kong-config.yaml
    # Wait for deployments to be ready
    - kubectl rollout status deployment -n ${K8S_NAMESPACE} --timeout=300s || true
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "master"
    - when: manual

# Deploy all at once (alternative single-job approach)
deploy-all:
  stage: deploy
  tags:
    - minikube
  needs:
    - build-images
  before_script:
    - kubectl config use-context minikube
  script:
    - echo "Deploying all resources to Minikube..."
    # Apply all k8s manifests in order
    - |
      for manifest in k8s/*.yaml; do
        echo "Applying $manifest..."
        kubectl apply -f "$manifest"
        sleep 2
      done
    # Show deployment status
    - kubectl get all -n ${K8S_NAMESPACE}
  rules:
    - when: manual

# Cleanup job - removes all resources
cleanup:
  stage: deploy
  tags:
    - minikube
  before_script:
    - kubectl config use-context minikube
  script:
    - echo "Cleaning up resources..."
    - kubectl delete namespace ${K8S_NAMESPACE} --ignore-not-found=true
  rules:
    - when: manual

# Verify deployment status
verify:
  stage: deploy
  tags:
    - minikube
  needs:
    - deploy-apps
  before_script:
    - kubectl config use-context minikube
  script:
    - echo "Verifying deployment..."
    - kubectl get pods -n ${K8S_NAMESPACE}
    - kubectl get services -n ${K8S_NAMESPACE}
    - kubectl get deployments -n ${K8S_NAMESPACE}
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "master"
    - when: manual
